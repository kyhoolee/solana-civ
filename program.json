{
    "programs/solciv/src/consts.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/consts.rs",
        "originalFileName": "programs/solciv/src/consts.rs",
        "content": "pub const MAX_UNITS: u8 = 20;\npub const MAX_CITIES: u8 = 20;\npub const MAX_BUILDINGS: u8 = 20;\npub const MAX_UPGRADED_TILES: u8 = 100;\npub const MAX_PRODUCTION_QUEUE: u8 = 5;\npub const MAP_BOUND: u8 = 20;\n\npub const GEMS_PER_KILL: [u8; 3] = [1, 1, 2];\npub const GEMS_PER_CITY_DESTROYED: [u8; 3] = [25, 50, 100];\n\npub const EXP_THRESHOLDS: [u8; 3] = [10, 30, 45];\npub const EXP_PER_ATTACK: u8 = 3;\npub const SPAWN_INTERVAL: [u8; 3] = [20, 15, 10];\n\n// default storage capacity per strategic resource\npub const STORAGE_CAPACITY: u8 = 50;\n"
    },
    "programs/solciv/src/errors.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/errors.rs",
        "originalFileName": "programs/solciv/src/errors.rs",
        "content": "use anchor_lang::error_code;\n\n#[error_code]\npub enum UnitError {\n    #[msg(\"Unit with given ID not found\")]\n    UnitNotFound,\n\n    #[msg(\"Unit cannot move this turn\")]\n    CannotMove,\n\n    #[msg(\"Out of movement range\")]\n    OutOfMovementRange,\n\n    #[msg(\"Out of map bounds\")]\n    OutOfMapBounds,\n\n    #[msg(\"Tile is occupied by another unit\")]\n    TileOccupied,\n\n    #[msg(\"The provided unit cannot perform this action\")]\n    InvalidUnitType,\n\n    #[msg(\"The provided unit is not at the required coordinates\")]\n    UnitWrongPosition,\n\n    #[msg(\"The provided unit cannot attack\")]\n    InvalidAttack,\n\n    #[msg(\"The provided unit is out of attack range\")]\n    OutOfAttackRange,\n\n    #[msg(\"No movement points left this turn\")]\n    NoMovementPoints,\n\n    #[msg(\"Unit is not damaged\")]\n    UnitNotDamaged,\n\n    #[msg(\"Not enough of food to heal the unit\")]\n    NotEnoughResources,\n\n    #[msg(\"Max level reached\")]\n    MaxLevelReached,\n\n    #[msg(\"Not enought experience to level up unit\")]\n    NotEnoughExp,\n\n    #[msg(\"Cannot build a city on this tile\")]\n    WithinControlledTerritory,\n}\n\n#[error_code]\npub enum BuildingError {\n    #[msg(\"Tile is occupied by another construction\")]\n    TileOccupied,\n}\n\n#[error_code]\npub enum TileError {\n    #[msg(\"Tile is not upgradeable\")]\n    NotUpgradeable,\n\n    #[msg(\"Tile is occupied by another construction\")]\n    TileOccupied,\n\n    #[msg(\"Tile doesn't belong to the player\")]\n    TileNotControlled,\n}\n\n#[error_code]\npub enum CityError {\n    #[msg(\"Production queue is full\")]\n    QueueFull,\n\n    #[msg(\"Building already exists\")]\n    BuildingAlreadyExists,\n\n    #[msg(\"City not found\")]\n    CityNotFound,\n\n    #[msg(\"Counstruction is already in progress\")]\n    AlreadyQueued,\n\n    #[msg(\"Not enough resources\")]\n    InsufficientResources,\n\n    #[msg(\"Invalid production item\")]\n    InvalidItem,\n\n    #[msg(\"Item not found in the production queue of the city\")]\n    QueueItemNotFound,\n\n    #[msg(\"Not enough gold\")]\n    InsufficientGold,\n\n    #[msg(\"Technology is not unlocked\")]\n    TechnologyNotResearched,\n\n    #[msg(\"Not enough wood\")]\n    InsufficientWood,\n\n    #[msg(\"Not enough stone\")]\n    InsufficientStone,\n\n    #[msg(\"Wall not damaged\")]\n    NotDamagedWall,\n\n    #[msg(\"No wall in the city\")]\n    NoWall,\n\n    #[msg(\"Not enough gold for maintenance\")]\n    InsufficientGoldForMaintenance,\n\n    #[msg(\"Not enough citizens to recruit a Settler\")]\n    InsufficientPopulationForSettler,\n}\n\n#[error_code]\npub enum ResearchError {\n    #[msg(\"Invalid research\")]\n    InvalidResearch,\n    #[msg(\"Research already in progress\")]\n    AlreadyResearching,\n    #[msg(\"Research already completed\")]\n    ResearchAlreadyCompleted,\n    #[msg(\"You need to unlock the previous technology first\")]\n    CannotResearch,\n    #[msg(\"Research not complete\")]\n    ResearchNotComplete,\n    #[msg(\"No active research\")]\n    NoActiveResearch,\n}\n\n#[error_code]\npub enum GameError {\n    #[msg(\"Not enough gems\")]\n    NotEnoughGems,\n}\n"
    },
    "programs/solciv/src/instructions/city.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/city.rs",
        "originalFileName": "programs/solciv/src/instructions/city.rs",
        "content": "use crate::consts::*;\nuse crate::errors::*;\nuse crate::state::*;\nuse anchor_lang::prelude::*;\n\npub fn add_to_production_queue(\n    ctx: Context<AddToProductionQueue>,\n    city_id: u32,\n    item: ProductionItem,\n) -> Result<()> {\n    let player_account = &mut ctx.accounts.player_account;\n\n    let city = player_account\n        .cities\n        .iter()\n        .find(|city| city.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    if (city.production_queue.len() as u8) >= MAX_PRODUCTION_QUEUE {\n        return err!(CityError::QueueFull);\n    }\n\n    // Settler has special conditions as it consumes 1 Citizen, so city population should be at least 2\n    if let ProductionItem::Unit(UnitType::Settler) = &item {\n        if city.population < 2 {\n            return err!(CityError::InsufficientPopulationForSettler);\n        }\n    }\n\n    let maintenance_cost = if let ProductionItem::Unit(unit_type) = &item {\n        Unit::get_maintenance_cost(*unit_type)\n    } else {\n        0\n    };\n    if maintenance_cost > 0 && player_account.resources.gold < 0 {\n        return err!(CityError::InsufficientGoldForMaintenance);\n    }\n\n    let total_cost = match &item {\n        ProductionItem::Building(building_type) => {\n            if !building_type.can_construct(&player_account.researched_technologies) {\n                return err!(CityError::TechnologyNotResearched);\n            }\n            if city.buildings.contains(building_type) {\n                return err!(CityError::BuildingAlreadyExists);\n            }\n            if city.production_queue.contains(&item) {\n                return err!(CityError::AlreadyQueued);\n            }\n            0 // No cost for building types\n        }\n        ProductionItem::Unit(unit_type) => {\n            if !unit_type.can_recruit(&player_account.researched_technologies) {\n                return err!(CityError::TechnologyNotResearched);\n            }\n            match unit_type {\n                UnitType::Settler => {\n                    // @todo: this now requires Population > 1\n                    // @todo: decrease population when the settler is recruited\n                    0\n                }\n                UnitType::Swordsman => Unit::get_resource_cost(*unit_type),\n                UnitType::Horseman => Unit::get_resource_cost(*unit_type),\n                _ => 0, // No resource cost for other unit types\n            }\n        }\n    };\n\n    // Perform the necessary deductions\n    if total_cost > 0 {\n        let resource_type = match &item {\n            ProductionItem::Unit(UnitType::Swordsman) => &mut player_account.resources.iron,\n            ProductionItem::Unit(UnitType::Horseman) => &mut player_account.resources.horses,\n            // can this really happen?\n            _ => return err!(CityError::InvalidItem),\n        };\n\n        if *resource_type < total_cost {\n            return err!(CityError::InsufficientResources);\n        }\n        *resource_type -= total_cost;\n    }\n\n    let city = player_account\n        .cities\n        .iter_mut()\n        .find(|city| city.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    city.production_queue.push(item);\n\n    Ok(())\n}\n\npub fn remove_from_production_queue(\n    ctx: Context<RemoveFromProductionQueue>,\n    city_id: u32,\n    index: u8,\n) -> Result<()> {\n    let player_account = &mut ctx.accounts.player_account;\n\n    let city = player_account\n        .cities\n        .iter_mut()\n        .find(|city| city.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    if index >= MAX_PRODUCTION_QUEUE {\n        return err!(CityError::QueueItemNotFound);\n    }\n\n    if city.production_queue.get(index as usize).is_none() {\n        return err!(CityError::QueueItemNotFound);\n    }\n\n    // @todo: refund the resources if applicable\n\n    // Remove the item from the production queue.\n    city.production_queue.remove(index as usize);\n\n    Ok(())\n}\n\npub fn repair_wall(ctx: Context<RepairWall>, city_id: u32) -> Result<()> {\n    let player_account: &mut Account<'_, Player> = &mut ctx.accounts.player_account;\n\n    // Encapsulate the logic in a separate block to release the borrow after use.\n    let (max_wall_hp, cost) = {\n        let city = player_account\n            .cities\n            .iter()\n            .find(|city| city.city_id == city_id)\n            .ok_or(CityError::CityNotFound)?;\n\n        let max_wall_hp = if city.buildings.contains(&BuildingType::WallIndustrial) {\n            200\n        } else if city.buildings.contains(&BuildingType::WallRenaissance) {\n            150\n        } else if city.buildings.contains(&BuildingType::WallMedieval) {\n            100\n        } else if city.buildings.contains(&BuildingType::Wall) {\n            50\n        } else {\n            return err!(CityError::NoWall);\n        };\n\n        // 1 hp to repair = 2 wood + 2 stone\n        let cost = (max_wall_hp - city.wall_health) * 2;\n        (max_wall_hp, cost)\n    };\n\n    // Check and deduct the player's wood balance.\n    if player_account.resources.wood < cost {\n        return err!(CityError::InsufficientWood);\n    }\n\n    // Check and deduct the player's wood balance.\n    if player_account.resources.stone < cost {\n        return err!(CityError::InsufficientStone);\n    }\n\n    player_account.resources.wood -= cost;\n    player_account.resources.stone -= cost;\n\n    let city = player_account\n        .cities\n        .iter_mut()\n        .find(|city| city.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    // Set city health to max\n    city.wall_health = max_wall_hp;\n\n    Ok(())\n}\n\npub fn purchase_with_gold(\n    ctx: Context<PurchaseWithGold>,\n    city_id: u32,\n    item: ProductionItem,\n) -> Result<()> {\n    let player_account = &mut ctx.accounts.player_account;\n    let next_unit_id = player_account.next_unit_id;\n    let player = player_account.player;\n    let game = player_account.game;\n    // Determine the cost of the unit/building.\n    let cost = match &item {\n        ProductionItem::Building(building_type) => {\n            BuildingType::get_gold_cost(*building_type) as i32\n        }\n        ProductionItem::Unit(unit_type) => Unit::get_gold_cost(*unit_type) as i32,\n    };\n\n    // Check the player's gold balance.\n    if player_account.resources.gold < cost {\n        return err!(CityError::InsufficientGold);\n    }\n\n    let researched_technologies = player_account.researched_technologies.clone();\n\n    // Deduct the cost from the player's gold balance.\n    player_account.resources.gold -= cost;\n\n    // Find the city by city_id.\n    let city = player_account\n        .cities\n        .iter_mut()\n        .find(|city| city.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    // Settler has special conditions as it consumes 1 Citizen, so city population should be at least 2\n    if let ProductionItem::Unit(UnitType::Settler) = &item {\n        if city.population < 2 {\n            return err!(CityError::InsufficientPopulationForSettler);\n        } else {\n            city.population -= 1;\n        }\n    }\n\n    // Add the unit/building to the player's assets.\n    match &item {\n        ProductionItem::Building(building_type) => {\n            // Check if the technology is unlocked\n            if !building_type.can_construct(&researched_technologies) {\n                return err!(CityError::TechnologyNotResearched);\n            }\n            // Check if the building already exists in the city.\n            if city.buildings.contains(building_type) {\n                return err!(CityError::BuildingAlreadyExists);\n            }\n\n            // Check if the building is in the city's production_queue.\n            // Remove, if so.\n            if let Some(index) = city.production_queue.iter().position(|&i| i == item) {\n                city.production_queue.remove(index);\n            }\n\n            city.construct_building(*building_type)?;\n        }\n        ProductionItem::Unit(unit_type) => {\n            if !unit_type.can_recruit(&researched_technologies) {\n                return err!(CityError::TechnologyNotResearched);\n            }\n            let unit = Unit::new(next_unit_id, player, game, *unit_type, city.x, city.y);\n            player_account.units.push(unit);\n            player_account.next_unit_id += 1;\n        }\n    }\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct RepairWall<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct AddToProductionQueue<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct RemoveFromProductionQueue<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct PurchaseWithGold<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n"
    },
    "programs/solciv/src/instructions/game.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/game.rs",
        "originalFileName": "programs/solciv/src/instructions/game.rs",
        "content": "use crate::consts::*;\nuse crate::state::*;\nuse anchor_lang::prelude::*;\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\npub fn initialize_game(\n    ctx: Context<InitializeGame>,\n    map: [u8; 400],\n    difficulty_level: u8,\n) -> Result<()> {\n    ctx.accounts.game.player = ctx.accounts.player.key();\n    ctx.accounts.game.turn = 1;\n    ctx.accounts.game.defeat = false;\n    ctx.accounts.game.victory = false;\n    ctx.accounts.game.difficulty_level = difficulty_level;\n\n    for i in 0..20 {\n        for j in 0..20 {\n            let index = i * 20 + j;\n            ctx.accounts.game.map[index].terrain = map[index];\n            ctx.accounts.game.map[index].discovered = false;\n        }\n    }\n\n    msg!(\"Game created!\");\n\n    Ok(())\n}\n\nfn heal_units_and_reset_movement_range(units: &mut [Unit]) {\n    for unit in units.iter_mut().filter(|u| u.is_alive) {\n        // Heal if the unit did not move/attack and has less than max HP\n        if unit.health < 100 && unit.movement_range == Unit::get_base_movement_range(unit.unit_type)\n        {\n            unit.health = std::cmp::min(unit.health + 5, 100);\n        }\n\n        // Reset movement range\n        unit.movement_range = Unit::get_base_movement_range(unit.unit_type);\n    }\n}\n\nfn find_adjacent_tiles(\n    tiles: &[TileCoordinate],\n    controlled_tiles: &[TileCoordinate],\n) -> Vec<TileCoordinate> {\n    let controlled_set: HashSet<_> = HashSet::from_iter(controlled_tiles.iter());\n    let tile_set: HashSet<_> = HashSet::from_iter(tiles.iter());\n\n    tiles\n        .iter()\n        .flat_map(adjacent_coords)\n        .filter(|coord| {\n            is_within_bounds(coord) && !tile_set.contains(coord) && !controlled_set.contains(coord)\n        })\n        .collect()\n}\n\nfn adjacent_coords(tile: &TileCoordinate) -> Vec<TileCoordinate> {\n    vec![\n        TileCoordinate {\n            x: tile.x,\n            y: tile.y.saturating_sub(1),\n        },\n        TileCoordinate {\n            x: tile.x,\n            y: tile.y + 1,\n        },\n        TileCoordinate {\n            x: tile.x.saturating_sub(1),\n            y: tile.y,\n        },\n        TileCoordinate {\n            x: tile.x + 1,\n            y: tile.y,\n        },\n    ]\n}\n\nfn is_within_bounds(coord: &TileCoordinate) -> bool {\n    coord.x < MAP_BOUND && coord.y < MAP_BOUND\n}\n\nfn calculate_resources(player_account: &Player) -> (i32, u32, u32, u32, u32, u32) {\n    // Calculate resources yielded by cities and tiles.\n    // This function will return a tuple (gold, wood, stone, iron, horses, science).\n    let mut resources: (i32, u32, u32, u32, u32, u32) = (0, 0, 0, 0, 0, 0);\n\n    for city in &player_account.cities {\n        resources.0 += city.gold_yield as i32;\n        resources.5 += city.science_yield;\n    }\n\n    for tile in &player_account.tiles {\n        match tile.tile_type {\n            TileType::LumberMill => resources.1 += 2,\n            TileType::StoneQuarry => resources.2 += 2,\n            TileType::IronMine => resources.3 += 2,\n            TileType::Pasture => resources.4 += 2,\n            _ => {} // Ignore other cases, including Farm\n        }\n    }\n\n    // Deduct unit maintenance costs from gold yield\n    for unit in &player_account.units {\n        resources.0 = resources\n            .0\n            .checked_sub(unit.maintenance_cost)\n            .unwrap_or(i32::MIN);\n    }\n\n    resources\n}\n\nfn process_production_queues(player_account: &mut Player, game_key: Pubkey) -> Result<()> {\n    let mut new_units = Vec::new();\n    let mut next_unit_id = player_account.next_unit_id;\n    let player = player_account.player;\n\n    for city in &mut player_account.cities {\n        if let Some(item) = city.production_queue.first().cloned() {\n            let cost = match item {\n                ProductionItem::Unit(unit_type) => Unit::get_base_stats(unit_type).5,\n                ProductionItem::Building(building_type) => {\n                    BuildingType::get_base_stats(building_type).0\n                }\n            };\n\n            // Increment the accumulated production by the city's production yield\n            city.accumulated_production += city.production_yield;\n\n            if city.accumulated_production >= cost {\n                // Production completed\n                match item {\n                    ProductionItem::Unit(unit_type) => {\n                        // If the unit is a Settler and the city population is greater than 1, decrease the population\n                        if unit_type == UnitType::Settler && city.population > 1 {\n                            city.population -= 1;\n                        }\n                        // Create a new unit and add it to the player's units\n                        let new_unit =\n                            Unit::new(next_unit_id, player, game_key, unit_type, city.x, city.y);\n                        new_units.push(new_unit);\n                        next_unit_id += 1;\n                    }\n                    ProductionItem::Building(building_type) => {\n                        // Construct the building in the city\n                        city.construct_building(building_type)?;\n                    }\n                }\n                // Remove the item from the production queue and reset accumulated_production\n                city.production_queue.remove(0);\n                city.accumulated_production = 0;\n            }\n        }\n    }\n\n    player_account.units.append(&mut new_units);\n    player_account.next_unit_id = next_unit_id;\n\n    Ok(())\n}\n\nfn process_npc_movements_and_attacks(\n    npc_units: &mut Vec<Unit>,\n    player: &mut Player,\n    difficulty_level: u8,\n) -> Result<()> {\n    let npc_units_count = npc_units.len();\n    for i in 0..npc_units_count {\n        if !npc_units[i].is_alive {\n            continue;\n        }\n\n        // Level up check\n        if npc_units[i].level < EXP_THRESHOLDS.len() as u8\n            && npc_units[i].experience >= EXP_THRESHOLDS[npc_units[i].level as usize]\n        {\n            npc_units[i].level += 1;\n            npc_units[i].attack += 2;\n            npc_units[i].health = std::cmp::min(npc_units[i].health + 30, 100);\n            npc_units[i].movement_range = 0;\n\n            msg!(\n                \"NPC unit #{} leveled up to level {}\",\n                npc_units[i].unit_id,\n                npc_units[i].level\n            );\n\n            continue; // Skip to the next unit\n        }\n\n        let mut min_dist = u16::MAX;\n        let mut closest_target: Option<(u8, u8)> = None;\n\n        // Find the closest player's unit or city to the NPC unit\n        for player_unit in player.units.iter().filter(|u| u.is_alive) {\n            let dist = ((npc_units[i].x as i16 - player_unit.x as i16).pow(2)\n                + (npc_units[i].y as i16 - player_unit.y as i16).pow(2))\n                as u16;\n            if dist < min_dist {\n                min_dist = dist;\n                closest_target = Some((player_unit.x, player_unit.y));\n            }\n        }\n\n        for city in player.cities.iter() {\n            let dist = ((npc_units[i].x as i16 - city.x as i16).pow(2)\n                + (npc_units[i].y as i16 - city.y as i16).pow(2)) as u16;\n            if dist < min_dist {\n                min_dist = dist;\n                closest_target = Some((city.x, city.y));\n            }\n        }\n\n        // If a closest target was found, make decisions for NPC units based on the proximity to this target\n        if let Some((target_x, target_y)) = closest_target {\n            let dist_x = (npc_units[i].x as i16 - target_x as i16).abs();\n            let dist_y = (npc_units[i].y as i16 - target_y as i16).abs();\n            let dist = std::cmp::max(dist_x, dist_y) as u8;\n\n            if dist == 1 {\n                let is_player_unit = player\n                    .units\n                    .iter_mut()\n                    .any(|u| u.x == target_x && u.y == target_y);\n                let is_city_with_wall = player.cities.iter_mut().any(|c| {\n                    c.x == target_x && c.y == target_y && c.health > 0 && c.wall_health > 0\n                });\n                if is_city_with_wall && is_player_unit {\n                    // attack unit that stay in the city with wall\n                    let player_unit = player\n                        .units\n                        .iter_mut()\n                        .find(|u| u.x == target_x && u.y == target_y && u.is_alive);\n                    npc_units[i].attack_unit(player_unit.unwrap(), Some(true))?;\n                    if !npc_units[i].is_alive {\n                        player.resources.gems = player\n                            .resources\n                            .gems\n                            .checked_add(GEMS_PER_KILL[difficulty_level as usize] as u32)\n                            .unwrap_or(u32::MAX);\n                    }\n                } else if let Some(player_unit) = player\n                    .units\n                    .iter_mut()\n                    .find(|u| u.x == target_x && u.y == target_y && u.is_alive)\n                {\n                    npc_units[i].attack_unit(player_unit, None)?;\n                    if !npc_units[i].is_alive {\n                        player.resources.gems = player\n                            .resources\n                            .gems\n                            .checked_add(GEMS_PER_KILL[difficulty_level as usize] as u32)\n                            .unwrap_or(u32::MAX);\n                    }\n                } else if let Some(player_city) = player\n                    .cities\n                    .iter_mut()\n                    .find(|c| c.x == target_x && c.y == target_y && c.health > 0)\n                {\n                    npc_units[i].attack_city(player_city)?;\n                    if !npc_units[i].is_alive {\n                        player.resources.gems = player\n                            .resources\n                            .gems\n                            .checked_add(GEMS_PER_KILL[difficulty_level as usize] as u32)\n                            .unwrap_or(u32::MAX);\n                    }\n                }\n            } else {\n                let dir_x = match npc_units[i].x.cmp(&target_x) {\n                    std::cmp::Ordering::Less => 1,\n                    std::cmp::Ordering::Greater => -1,\n                    std::cmp::Ordering::Equal => 0,\n                };\n                let dir_y = match npc_units[i].y.cmp(&target_y) {\n                    std::cmp::Ordering::Less => 1,\n                    std::cmp::Ordering::Greater => -1,\n                    std::cmp::Ordering::Equal => 0,\n                };\n\n                let new_x = (npc_units[i].x as i16 + dir_x) as u8;\n                let new_y = (npc_units[i].y as i16 + dir_y) as u8;\n\n                if new_x < MAP_BOUND\n                    && new_y < MAP_BOUND\n                    && !is_occupied(new_x, new_y, &player.units, npc_units, &player.cities)\n                {\n                    npc_units[i].x = new_x;\n                    npc_units[i].y = new_y;\n                } else {\n                    msg!(\n                        \"NPC unit #{} cannot move to position ({}, {})\",\n                        npc_units[i].unit_id,\n                        new_x,\n                        new_y\n                    );\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\nfn is_occupied(\n    x: u8,\n    y: u8,\n    player_units: &[Unit],\n    npc_units: &[Unit],\n    player_cities: &[City],\n) -> bool {\n    player_units\n        .iter()\n        .any(|u| u.x == x && u.y == y && u.is_alive)\n        || npc_units.iter().any(|u| u.x == x && u.y == y && u.is_alive)\n        || player_cities.iter().any(|c| c.x == x && c.y == y)\n}\n\nfn required_food_for_growth(population: u32) -> u32 {\n    (0.1082 * (population as f64).powf(2.0) + 10.171 * population as f64 + 1.929) as u32\n}\n\npub fn end_turn(ctx: Context<EndTurn>) -> Result<()> {\n    // check if the game is over via defeat or victory\n    if ctx.accounts.game.defeat || ctx.accounts.game.victory {\n        return Ok(());\n    }\n\n    // Calculate and update player's resources\n    let (gold, wood, stone, iron, horses, science) =\n        calculate_resources(&ctx.accounts.player_account);\n    ctx.accounts\n        .player_account\n        .update_resources(gold, wood, stone, iron, horses)?;\n\n    let player_account = &mut ctx.accounts.player_account;\n\n    process_npc_movements_and_attacks(\n        &mut ctx.accounts.npc_account.units,\n        player_account,\n        ctx.accounts.game.difficulty_level,\n    )?;\n\n    // Retain only alive units in the game\n    player_account.units.retain(|u| u.is_alive);\n    player_account.cities.retain(|c| c.health > 0);\n    ctx.accounts.npc_account.units.retain(|u| u.is_alive);\n    ctx.accounts.npc_account.cities.retain(|c| c.health > 0);\n\n    for i in 0..player_account.cities.len() {\n        let all_controlled_tiles: Vec<TileCoordinate> = player_account\n            .cities\n            .iter()\n            .flat_map(|city| &city.controlled_tiles)\n            .cloned()\n            .collect();\n\n        let city = &mut player_account.cities[i];\n\n        city.accumulated_food += city.food_yield as i32;\n\n        // Deduct food for population maintenance\n        let food_consumption = city.population * 2; // 2 food per citizen\n        city.accumulated_food -= food_consumption as i32;\n\n        if city.accumulated_food >= 0 {\n            let required_food = required_food_for_growth(city.population);\n            if city.accumulated_food as u32 >= required_food && city.population < city.housing {\n                city.population += 1;\n                city.accumulated_food = 0;\n            }\n        } else {\n            // Handle population decrease due to food shortage\n            if city.population > 1 {\n                city.population -= 1;\n                city.accumulated_food = 0;\n            }\n        }\n\n        // Auto-healing of cities\n        if city.health < 100 {\n            city.health = std::cmp::min(city.health + 5, 100);\n        }\n\n        // growth city\n        city.growth_points += city.population; // 1 citizen growth points generated\n        let points_need = 10.0 + (6.0 * city.level as f32).powf(1.3);\n\n        if city.growth_points as f32 >= points_need {\n            city.growth_points = 0;\n            city.level += 1;\n\n            let adjacent_tiles = find_adjacent_tiles(&city.controlled_tiles, &all_controlled_tiles);\n\n            if !adjacent_tiles.is_empty() {\n                let clock = Clock::get()?;\n                let random_factor = clock.unix_timestamp as usize % adjacent_tiles.len();\n                city.controlled_tiles.push(adjacent_tiles[random_factor]);\n            };\n        }\n    }\n\n    // The healing should happen only after NPC attacks\n    // Reset units' movement range & heal if needed\n    heal_units_and_reset_movement_range(&mut ctx.accounts.player_account.units);\n\n    // Process the production queues of each city for the player\n    let game_key = ctx.accounts.game.key();\n    process_production_queues(&mut ctx.accounts.player_account, game_key)?;\n\n    // Check research progress\n    ctx.accounts.player_account.add_research_points(science)?;\n\n    let spawn_interval = SPAWN_INTERVAL[ctx.accounts.game.difficulty_level as usize];\n\n    // Determine the epoch based on the game turn and difficulty level\n    let epoch = match ctx.accounts.game.difficulty_level {\n        0 => ctx.accounts.game.turn / 100, // Easy: NPCs evolve every 100 turns\n        1 => ctx.accounts.game.turn / 80,  // Medium: NPCs evolve every 80 turns\n        2 => ctx.accounts.game.turn / 60,  // Hard: NPCs evolve every 60 turns\n        _ => ctx.accounts.game.turn / 80,  // Default to Medium\n    };\n\n    if ctx.accounts.game.turn % spawn_interval as u32 == 0 {\n        let clock = Clock::get()?;\n        let random_factor = clock.unix_timestamp % 10;\n\n        // Temporary vector to store new units.\n        let mut new_units = Vec::new();\n        let mut next_npc_id = ctx.accounts.npc_account.next_unit_id;\n\n        for city in &ctx.accounts.npc_account.cities {\n            let unit_type = match epoch {\n                0 => {\n                    if random_factor < 5 {\n                        UnitType::Warrior\n                    } else {\n                        UnitType::Archer\n                    }\n                }\n                1 => {\n                    if random_factor < 5 {\n                        UnitType::Swordsman\n                    } else {\n                        UnitType::Horseman\n                    }\n                }\n                2 => {\n                    if random_factor < 5 {\n                        UnitType::Crossbowman\n                    } else {\n                        UnitType::Musketman\n                    }\n                }\n                _ => {\n                    if random_factor < 5 {\n                        UnitType::Rifleman\n                    } else {\n                        UnitType::Tank\n                    }\n                } // Default to latest epoch\n            };\n\n            let new_unit = Unit::new(\n                next_npc_id,\n                ctx.accounts.npc_account.player,\n                ctx.accounts.game.key(),\n                unit_type,\n                city.x,\n                city.y,\n            );\n            new_units.push(new_unit);\n            next_npc_id += 1;\n        }\n        ctx.accounts.npc_account.units.append(&mut new_units);\n        ctx.accounts.npc_account.next_unit_id = next_npc_id;\n    }\n    // if player has no units and no cities set game defeat to true\n    if ctx.accounts.player_account.units.is_empty() && ctx.accounts.player_account.cities.is_empty()\n    {\n        ctx.accounts.game.defeat = true;\n    } else if ctx.accounts.npc_account.units.is_empty()\n        && ctx.accounts.npc_account.cities.is_empty()\n    {\n        ctx.accounts.game.victory = true;\n    }\n\n    ctx.accounts.game.turn += 1;\n    Ok(())\n}\n\npub fn close_game(_ctx: Context<Close>) -> Result<()> {\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializeGame<'info> {\n    #[account(\n        init,\n        seeds=[b\"GAME\", player.key().as_ref()],\n        bump,\n        payer = player,\n        space = std::mem::size_of::<Game>() + 8\n    )]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct EndTurn<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut, has_one = player)]\n    pub npc_account: Account<'info, Npc>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Close<'info> {\n    #[account(mut, close = player, has_one = player)]\n    game: Box<Account<'info, Game>>,\n    #[account(mut, close = player, has_one = player)]\n    player_account: Account<'info, Player>,\n    #[account(mut, close = player, has_one = player)]\n    npc_account: Account<'info, Npc>,\n    #[account(mut)]\n    player: Signer<'info>,\n}\n"
    },
    "programs/solciv/src/instructions/npc.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/npc.rs",
        "originalFileName": "programs/solciv/src/instructions/npc.rs",
        "content": "use crate::consts::*;\nuse crate::state::*;\nuse anchor_lang::prelude::*;\n\npub fn initialize_npc(\n    ctx: Context<InitializeNpc>,\n    npc_position_1: TileCoordinate,\n    npc_position_2: TileCoordinate,\n) -> Result<()> {\n    ctx.accounts.npc_account.game = ctx.accounts.game.key();\n    ctx.accounts.npc_account.player = ctx.accounts.player.key();\n    ctx.accounts.npc_account.next_city_id = 0;\n    ctx.accounts.npc_account.next_unit_id = 0;\n    ctx.accounts.game.npc = ctx.accounts.npc_account.key();\n\n    let npc_one = NewCityParams {\n        city_id: 0,\n        player: ctx.accounts.npc_account.player,\n        game: ctx.accounts.game.key(),\n        x: npc_position_1.x,\n        y: npc_position_1.y,\n        name: \"Barbarian Village\".to_string(),\n        health: 1000,\n        controlled_tiles: vec![TileCoordinate {\n            x: npc_position_1.x,\n            y: npc_position_1.y,\n        }],\n    };\n    let npc_two = NewCityParams {\n        city_id: 1,\n        player: ctx.accounts.npc_account.player,\n        game: ctx.accounts.game.key(),\n        x: npc_position_2.x,\n        y: npc_position_2.y,\n        name: \"Barbarian Village\".to_string(),\n        health: 1000,\n        controlled_tiles: vec![TileCoordinate {\n            x: npc_position_2.x,\n            y: npc_position_2.y,\n        }],\n    };\n    ctx.accounts.npc_account.cities = vec![City::new(npc_one), City::new(npc_two)];\n\n    // Initialize units for the NPC.\n    ctx.accounts.npc_account.units = vec![Unit::new(\n        0,\n        ctx.accounts.npc_account.key(),\n        ctx.accounts.game.key(),\n        UnitType::Warrior,\n        npc_position_1.x + 1,\n        npc_position_1.y,\n    )];\n    ctx.accounts.npc_account.next_unit_id = 1;\n    ctx.accounts.npc_account.next_city_id = 2;\n\n    msg!(\"NPC created!\");\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializeNpc<'info> {\n    pub game: Box<Account<'info, Game>>,\n\n    #[account(\n        init,\n        seeds=[\n            b\"NPC\",\n            game.key().as_ref(),\n        ],\n        bump,\n        payer = player,\n        space = std::mem::size_of::<Npc>() +\n            4 + (20 * MAX_CITIES as usize) +\n            std::mem::size_of::<Unit>() * MAX_UNITS as usize +\n            std::mem::size_of::<City>() * MAX_CITIES as usize + 8)\n    ]\n    pub npc_account: Box<Account<'info, Npc>>,\n\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n"
    },
    "programs/solciv/src/instructions/mint.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/mint.rs",
        "originalFileName": "programs/solciv/src/instructions/mint.rs",
        "content": "use crate::errors::GameError;\nuse crate::state::Player;\nuse anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    metadata::{create_metadata_accounts_v3, CreateMetadataAccountsV3, Metadata},\n    token::{mint_to, Mint, MintTo, Token, TokenAccount},\n};\nuse mpl_token_metadata::{utils::find_metadata_account, state::DataV2};\n\npub fn mint_gems(ctx: Context<MintGems>) -> Result<()> {\n    // Ensure player has gems\n    let gems = ctx.accounts.player_account.resources.gems as u64;\n    if gems == 0 {\n        return err!(GameError::NotEnoughGems);\n    }\n\n    // Calculate amount safely\n    let amount = gems\n        .checked_mul(1_000_000_000)\n        .ok_or(GameError::CalculationOverflow)?;\n\n    ctx.accounts.player_account.resources.gems = 0;\n\n    // PDA signer seeds\n    let seeds = &[\"mint\".as_bytes(), &[ctx.bumps.mint]];\n    let signer = [&seeds[..]];\n\n    mint_to(\n        CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                authority: ctx.accounts.mint.to_account_info(),\n                to: ctx.accounts.destination.to_account_info(),\n                mint: ctx.accounts.mint.to_account_info(),\n            },\n            &signer,\n        ),\n        amount,\n    )?;\n\n    Ok(())\n}\n\npub fn create_gems(\n    ctx: Context<CreateGems>,\n    token_name: String,\n    token_symbol: String,\n    token_uri: String,\n) -> Result<()> {\n    msg!(\"Creating metadata account\");\n\n    // PDA signer seeds\n    let signer_seeds: &[&[&[u8]]] = &[&[b\"mint\", &[ctx.bumps.mint_account]]];\n\n    // Validate metadata account address\n    assert_eq!(\n        ctx.accounts.metadata_account.key(),\n        find_metadata_account(&ctx.accounts.mint_account.key()).0,\n        \"Invalid metadata account\"\n    );\n\n    // Invoke the create_metadata_account_v3 CPI\n    create_metadata_accounts_v3(\n        CpiContext::new(\n            ctx.accounts.token_metadata_program.to_account_info(),\n            CreateMetadataAccountsV3 {\n                metadata: ctx.accounts.metadata_account.to_account_info(),\n                mint: ctx.accounts.mint_account.to_account_info(),\n                mint_authority: ctx.accounts.mint_account.to_account_info(),\n                update_authority: ctx.accounts.mint_account.to_account_info(),\n                payer: ctx.accounts.payer.to_account_info(),\n                system_program: ctx.accounts.system_program.to_account_info(),\n                rent: ctx.accounts.rent.to_account_info(),\n            },\n        )\n        .with_signer(signer_seeds),\n        DataV2 {\n            name: token_name,\n            symbol: token_symbol,\n            uri: token_uri,\n            seller_fee_basis_points: 0,\n            creators: None,\n            collection: None,\n            uses: None,\n        },\n        false, // Is mutable\n        true,  // Update authority is signer\n        None,  // Collection details\n    )?;\n\n    msg!(\"Token created successfully.\");\n\n    Ok(())\n}\n"
    },
    "programs/solciv/src/instructions/player.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/player.rs",
        "originalFileName": "programs/solciv/src/instructions/player.rs",
        "content": "use crate::consts::*;\nuse crate::state::*;\nuse anchor_lang::prelude::*;\n\npub fn initialize_player(ctx: Context<InitializePlayer>, position: TileCoordinate) -> Result<()> {\n    ctx.accounts.player_account.game = ctx.accounts.game.key();\n    ctx.accounts.player_account.player = ctx.accounts.player.key();\n    ctx.accounts.player_account.points = 0;\n    ctx.accounts.player_account.next_city_id = 0;\n    ctx.accounts.player_account.next_unit_id = 0;\n    // @todo: consider implementing helper methods for initializing the resources, units or other default things\n    ctx.accounts.player_account.resources = Resources {\n        gold: 0,\n        wood: 0,\n        stone: 0,\n        iron: 0,\n        gems: 0,\n        horses: 0,\n    };\n    // player starts with 3 units: Settler, Builder, Warrior\n    ctx.accounts.player_account.units = vec![\n        Unit::new(\n            0,\n            ctx.accounts.player.key(),\n            ctx.accounts.game.key(),\n            UnitType::Settler,\n            position.x,\n            position.y,\n        ),\n        Unit::new(\n            1,\n            ctx.accounts.player.key(),\n            ctx.accounts.game.key(),\n            UnitType::Builder,\n            position.x + 1,\n            position.y,\n        ),\n        Unit::new(\n            2,\n            ctx.accounts.player.key(),\n            ctx.accounts.game.key(),\n            UnitType::Warrior,\n            position.x,\n            position.y + 1,\n        ),\n    ];\n    ctx.accounts.player_account.next_unit_id = 3;\n\n    ctx.accounts.player_account.researched_technologies = vec![];\n\n    /* Set surrounding tiles to 'discovered' */\n    let start_x = position.x.saturating_sub(2).max(0);\n    let end_x = position.x.saturating_add(2).min(MAP_BOUND - 1);\n    let start_y = position.y.saturating_sub(2).max(0);\n    let end_y = position.y.saturating_add(2).min(MAP_BOUND - 1);\n\n    for i in start_x..=end_x {\n        for j in start_y..=end_y {\n            let index = (j as usize) * MAP_BOUND as usize + i as usize;\n            ctx.accounts.game.map[index].discovered = true;\n        }\n    }\n\n    msg!(\"Player created!\");\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitializePlayer<'info> {\n    #[account(mut)]\n    pub game: Box<Account<'info, Game>>,\n\n    #[account(\n        init,\n        seeds=[\n            b\"PLAYER\",\n            game.key().as_ref(),\n            player.key().as_ref()\n        ],\n        bump,\n        payer = player,\n        space = std::mem::size_of::<Player>() +\n            4 + (15 * MAX_CITIES as usize) +\n            std::mem::size_of::<Unit>() * MAX_UNITS as usize +\n            std::mem::size_of::<City>() * MAX_CITIES as usize +\n            std::mem::size_of::<Tile>() * MAX_UPGRADED_TILES as usize +\n            std::mem::size_of::<BuildingType>() * MAX_BUILDINGS as usize +\n            std::mem::size_of::<Resources>() + 8)\n    ]\n    pub player_account: Box<Account<'info, Player>>,\n\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n"
    },
    "programs/solciv/src/instructions/unit.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/unit.rs",
        "originalFileName": "programs/solciv/src/instructions/unit.rs",
        "content": "use crate::consts::*;\nuse crate::errors::*;\nuse crate::state::*;\nuse crate::utils::*;\nuse anchor_lang::prelude::*;\n\npub fn move_unit(ctx: Context<MoveUnit>, unit_id: u32, x: u8, y: u8) -> Result<()> {\n    let unit = ctx\n        .accounts\n        .player_account\n        .units\n        .iter()\n        .find(|u| u.unit_id == unit_id)\n        .ok_or(UnitError::UnitNotFound)?;\n    let base_movement_range = Unit::get_base_movement_range(unit.unit_type);\n\n    // Check if the tile is within the map bounds\n    if x >= MAP_BOUND || y >= MAP_BOUND {\n        return err!(UnitError::OutOfMapBounds);\n    }\n\n    // Check if the unit has remaining movement_range points\n    if unit.movement_range == 0 {\n        return err!(UnitError::CannotMove);\n    }\n\n    // Check if the new position is within the movement_range\n    // Manhattan Distance:\n    let dist = ((unit.x as i16 - x as i16).abs() + (unit.y as i16 - y as i16).abs()) as u8;\n    msg!(\"Initial position: ({}, {})\", unit.x, unit.y);\n    msg!(\"New position: ({}, {})\", x, y);\n    msg!(\"Distance: {}\", dist);\n    if dist > unit.movement_range {\n        return err!(UnitError::OutOfMovementRange);\n    }\n\n    // Check if the tile is not occupied by another unit\n    if ctx\n        .accounts\n        .player_account\n        .units\n        .iter()\n        .any(|u| u.x == x && u.y == y && u.unit_id != unit_id)\n    {\n        return err!(UnitError::TileOccupied);\n    }\n\n    let units = &mut ctx.accounts.player_account.units;\n\n    // Find the index of the unit with the given unit_id\n    let unit_idx = units\n        .iter()\n        .position(|u| u.unit_id == unit_id)\n        .ok_or(UnitError::UnitNotFound)?;\n\n    // Update the coordinates of the unit\n    ctx.accounts.player_account.units[unit_idx].x = x;\n    ctx.accounts.player_account.units[unit_idx].y = y;\n    ctx.accounts.player_account.units[unit_idx].movement_range -= dist;\n\n    // Mark tiles within movement range as discovered\n    let start_x = x.saturating_sub(base_movement_range);\n    let end_x = std::cmp::min(x + base_movement_range, 19);\n    let start_y = y.saturating_sub(base_movement_range);\n    let end_y = std::cmp::min(y + base_movement_range, 19);\n\n    for j in start_y..=end_y {\n        for i in start_x..=end_x {\n            let dist = ((i as i16 - x as i16).abs() + (j as i16 - y as i16).abs()) as u8;\n            if dist <= base_movement_range {\n                let index = (j as usize) * 20 + (i as usize);\n                ctx.accounts.game.map[index].discovered = true;\n            }\n        }\n    }\n\n    Ok(())\n}\n\npub fn upgrade_unit(ctx: Context<UpgradeUnit>, unit_id: u32) -> Result<()> {\n    let units = &mut ctx.accounts.player_account.units;\n    let unit_idx = units\n        .iter()\n        .position(|u| u.unit_id == unit_id)\n        .ok_or(UnitError::UnitNotFound)?;\n\n    let unit_exp = units[unit_idx].experience;\n    let unit_level = units[unit_idx].level;\n    let unit_health = units[unit_idx].health;\n    let unit_movement_range = units[unit_idx].movement_range;\n\n    // Unit doesn't have movement range\n    if unit_movement_range == 0 {\n        return err!(UnitError::NoMovementPoints);\n    }\n\n    // Check if max level was reached\n    if unit_level >= EXP_THRESHOLDS.len() as u8 {\n        return err!(UnitError::MaxLevelReached);\n    }\n\n    // Check if unit has enough experience to level up\n    if unit_exp < EXP_THRESHOLDS[unit_level as usize] {\n        return err!(UnitError::NotEnoughExp);\n    }\n\n    // Level Up\n    if unit_health >= 70 {\n        ctx.accounts.player_account.units[unit_idx].health = 100;\n    } else {\n        ctx.accounts.player_account.units[unit_idx].health += 30;\n    }\n\n    ctx.accounts.player_account.units[unit_idx].attack += 2;\n    ctx.accounts.player_account.units[unit_idx].level += 1;\n\n    // After the upgrade, the unit cannot move or attack anymore\n    ctx.accounts.player_account.units[unit_idx].movement_range = 0;\n\n    Ok(())\n}\n\nfn calculate_controlled_tiles(x: u8, y: u8, existing_cities: &[City]) -> Vec<TileCoordinate> {\n    let mut tiles = Vec::new();\n\n    for dx in -2..=2 {\n        for dy in -2..=2 {\n            let tile_x = (x as i16 + dx) as u8;\n            let tile_y = (y as i16 + dy) as u8;\n\n            // Check map boundaries and existing city control\n            if tile_x < MAP_BOUND\n                && tile_y < MAP_BOUND\n                && !existing_cities\n                    .iter()\n                    .any(|city| city.controls_tile(tile_x, tile_y))\n            {\n                tiles.push(TileCoordinate {\n                    x: tile_x,\n                    y: tile_y,\n                });\n            }\n        }\n    }\n\n    tiles\n}\n\npub fn found_city(ctx: Context<FoundCity>, x: u8, y: u8, unit_id: u32, name: String) -> Result<()> {\n    // Validate if the unit with `unit_id` is a settler and is at `x` and `y`.\n    let unit_idx = ctx\n        .accounts\n        .player_account\n        .units\n        .iter()\n        .position(|u| u.unit_id == unit_id)\n        .ok_or(UnitError::UnitNotFound)?;\n    let unit = &ctx.accounts.player_account.units[unit_idx];\n    if unit.unit_type != UnitType::Settler {\n        return err!(UnitError::InvalidUnitType);\n    }\n    if (unit.x, unit.y) != (x, y) {\n        return err!(UnitError::UnitWrongPosition);\n    }\n    if unit.movement_range == 0 {\n        return err!(UnitError::NoMovementPoints);\n    }\n\n    // Check if the tile is not neutral\n    let is_controlled = ctx\n        .accounts\n        .player_account\n        .cities\n        .iter()\n        .any(|city| city.controls_tile(x, y));\n\n    if is_controlled {\n        return err!(UnitError::WithinControlledTerritory);\n    }\n\n    let controlled_tiles = calculate_controlled_tiles(x, y, &ctx.accounts.player_account.cities);\n\n    // Initialize the new City.\n    let params = NewCityParams {\n        city_id: ctx.accounts.player_account.next_city_id,\n        player: ctx.accounts.player_account.player,\n        game: ctx.accounts.game.key(),\n        x,\n        y,\n        name,\n        health: 100,\n        controlled_tiles: controlled_tiles.clone(),\n    };\n\n    let new_city = City::new(params);\n\n    ctx.accounts.player_account.cities.push(new_city);\n\n    // Mark controlled tiles as discovered\n    for tile_coord in controlled_tiles {\n        let tile_index = (tile_coord.y as usize * MAP_BOUND as usize) + tile_coord.x as usize;\n        ctx.accounts.game.map[tile_index].discovered = true;\n    }\n\n    // Remove the settler unit used to found the city.\n    ctx.accounts.player_account.units.remove(unit_idx);\n\n    // Update the next_city_id in the player account.\n    ctx.accounts.player_account.next_city_id = ctx\n        .accounts\n        .player_account\n        .next_city_id\n        .checked_add(1)\n        .unwrap();\n\n    msg!(\"Founded new city!\");\n\n    Ok(())\n}\n\npub fn upgrade_tile(ctx: Context<UpgradeTile>, x: u8, y: u8, unit_id: u32) -> Result<()> {\n    // Validate if the unit with `unit_id` is a Builder and is at `x` and `y`.\n    let unit_idx = ctx\n        .accounts\n        .player_account\n        .units\n        .iter()\n        .position(|u| u.unit_id == unit_id)\n        .ok_or(UnitError::UnitNotFound)?;\n    let unit = &ctx.accounts.player_account.units[unit_idx];\n    if unit.unit_type != UnitType::Builder {\n        return err!(UnitError::InvalidUnitType);\n    }\n    if (unit.x, unit.y) != (x, y) {\n        return err!(UnitError::UnitWrongPosition);\n    }\n    if unit.movement_range == 0 {\n        return err!(UnitError::NoMovementPoints);\n    }\n\n    // Check if the tile type is upgradeable and the tile is not occupied by a City or another Tile.\n    let map_idx = (y as usize) * MAP_BOUND as usize + x as usize;\n    match ctx.accounts.game.map[map_idx].terrain {\n        1 | 2 | 5 | 6 | 7 => {} // allowable tile types\n        _ => return err!(TileError::NotUpgradeable),\n    }\n\n    if ctx\n        .accounts\n        .player_account\n        .cities\n        .iter()\n        .any(|city| city.x == x && city.y == y)\n        || ctx\n            .accounts\n            .player_account\n            .tiles\n            .iter()\n            .any(|tile| tile.x == x && tile.y == y)\n    {\n        return err!(TileError::TileOccupied);\n    }\n\n    // Check if the tile is controlled by any of the player's cities\n    let controlling_city_id = ctx\n        .accounts\n        .player_account\n        .cities\n        .iter()\n        .find(|city| {\n            city.controlled_tiles\n                .iter()\n                .any(|tile| tile.x == x && tile.y == y)\n        })\n        .map(|city| city.city_id)\n        .ok_or(TileError::TileNotControlled)?;\n\n    // Initialize the new Tile and push it to player_account tiles vector.\n    let tile_type = match ctx.accounts.game.map[map_idx].terrain {\n        1 => TileType::IronMine,\n        2 => TileType::LumberMill,\n        5 => TileType::StoneQuarry,\n        6 => TileType::Farm,\n        7 => TileType::Pasture,\n        // we've already checked the tile type above, if there was no match, we would have returned an error NotUpgradeable\n        _ => unreachable!(),\n    };\n\n    let new_tile = Tile::new(tile_type, x, y);\n    ctx.accounts.player_account.tiles.push(new_tile);\n\n    // Special case for Farm: increase the city's food yield\n    if tile_type == TileType::Farm {\n        let city = ctx\n            .accounts\n            .player_account\n            .cities\n            .iter_mut()\n            .find(|city| city.city_id == controlling_city_id)\n            .ok_or(TileError::TileNotControlled)?;\n        city.food_yield += 2;\n    }\n\n    // Reduce remaining_actions of the Builder and remove it if remaining_actions hit 0.\n    ctx.accounts.player_account.units[unit_idx].remaining_actions -= 1;\n    if ctx.accounts.player_account.units[unit_idx].remaining_actions == 0 {\n        ctx.accounts.player_account.units.remove(unit_idx);\n    }\n\n    msg!(\"Tile upgraded!\");\n\n    Ok(())\n}\n\npub fn attack_unit(ctx: Context<AttackUnit>, attacker_id: u32, defender_id: u32) -> Result<()> {\n    let attacker = ctx\n        .accounts\n        .player_account\n        .units\n        .iter_mut()\n        .find(|u| u.unit_id == attacker_id)\n        .ok_or(UnitError::UnitNotFound)?;\n    let defender = ctx\n        .accounts\n        .npc_account\n        .units\n        .iter_mut()\n        .find(|u| u.unit_id == defender_id)\n        .ok_or(UnitError::UnitNotFound)?;\n\n    if attacker.movement_range == 0 {\n        return err!(UnitError::NoMovementPoints);\n    }\n\n    // Check proximity (attacker should be 1 tile away from defender)\n    // Chebyshev Distance:\n    let dist_x = (attacker.x as i16 - defender.x as i16).abs();\n    let dist_y = (attacker.y as i16 - defender.y as i16).abs();\n    let dist = std::cmp::max(dist_x, dist_y) as u8;\n\n    if dist != 1 {\n        return err!(UnitError::OutOfAttackRange);\n    }\n\n    attacker.attack_unit(defender, None)?;\n\n    if !defender.is_alive {\n        ctx.accounts.player_account.resources.gems = ctx\n            .accounts\n            .player_account\n            .resources\n            .gems\n            .checked_add(GEMS_PER_KILL[ctx.accounts.game.difficulty_level as usize] as u32)\n            .unwrap_or(u32::MAX);\n    }\n\n    // Retain only alive units in the game\n    ctx.accounts.player_account.units.retain(|u| u.is_alive);\n    ctx.accounts.npc_account.units.retain(|u| u.is_alive);\n\n    Ok(())\n}\n\npub fn attack_city(ctx: Context<AttackCity>, attacker_id: u32, city_id: u32) -> Result<()> {\n    let attacker = ctx\n        .accounts\n        .player_account\n        .units\n        .iter_mut()\n        .find(|u| u.unit_id == attacker_id)\n        .ok_or(UnitError::UnitNotFound)?;\n\n    if attacker.movement_range == 0 {\n        return err!(UnitError::NoMovementPoints);\n    }\n\n    let target_city = ctx\n        .accounts\n        .npc_account\n        .cities\n        .iter_mut()\n        .find(|c| c.city_id == city_id)\n        .ok_or(CityError::CityNotFound)?;\n\n    let dist_x = (attacker.x as i16 - target_city.x as i16).abs();\n    let dist_y = (attacker.y as i16 - target_city.y as i16).abs();\n    let dist = std::cmp::max(dist_x, dist_y) as u8;\n\n    if dist != 1 {\n        return err!(UnitError::OutOfAttackRange);\n    }\n\n    attacker.attack_city(target_city)?;\n    attacker.movement_range = 0;\n    attacker.experience = get_new_exp(attacker.level, attacker.experience, 3);\n\n    let city_was_destroyed = target_city.health == 0;\n\n    if city_was_destroyed {\n        ctx.accounts.player_account.resources.gems = ctx\n            .accounts\n            .player_account\n            .resources\n            .gems\n            .checked_add(\n                GEMS_PER_CITY_DESTROYED[ctx.accounts.game.difficulty_level as usize] as u32,\n            )\n            .unwrap_or(u32::MAX);\n    }\n\n    ctx.accounts.player_account.units.retain(|u| u.is_alive);\n    ctx.accounts.npc_account.cities.retain(|c| c.health > 0);\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct FoundCity<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Account<'info, Game>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct MoveUnit<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct HealUnit<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct UpgradeUnit<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct UpgradeTile<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct AttackUnit<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut, has_one = player)]\n    pub npc_account: Account<'info, Npc>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct AttackCity<'info> {\n    #[account(mut, has_one = player)]\n    pub game: Box<Account<'info, Game>>,\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut, has_one = player)]\n    pub npc_account: Account<'info, Npc>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n"
    },
    "programs/solciv/src/instructions/mod.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/mod.rs",
        "originalFileName": "programs/solciv/src/instructions/mod.rs",
        "content": "pub mod city;\npub mod game;\npub mod mint;\npub mod npc;\npub mod player;\npub mod science;\npub mod unit;\n\npub use city::*;\npub use game::*;\npub use mint::*;\npub use npc::*;\npub use player::*;\npub use science::*;\npub use unit::*;\n"
    },
    "programs/solciv/src/instructions/science.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/instructions/science.rs",
        "originalFileName": "programs/solciv/src/instructions/science.rs",
        "content": "use crate::errors::*;\nuse crate::state::*;\nuse anchor_lang::prelude::*;\n\npub fn start_research(ctx: Context<StartResearch>, technology_type: TechnologyType) -> Result<()> {\n    let player_account = &mut ctx.accounts.player_account;\n\n    // Ensure the research hasn't already been started or completed.\n    if player_account\n        .researched_technologies\n        .contains(&technology_type)\n    {\n        return err!(ResearchError::ResearchAlreadyCompleted);\n    }\n\n    player_account.start_research(technology_type)?;\n\n    msg!(\"Research started!\");\n\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct StartResearch<'info> {\n    #[account(mut, has_one = player)]\n    pub player_account: Account<'info, Player>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n"
    },
    "programs/solciv/src/lib.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/lib.rs",
        "originalFileName": "programs/solciv/src/lib.rs",
        "content": "#![allow(clippy::result_large_err)]\n\nmod consts;\nmod errors;\nmod instructions;\nmod state;\nmod utils;\n\nuse crate::instructions::*;\nuse crate::state::{ProductionItem, TechnologyType, TileCoordinate};\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"3qoyRXbpBJDPfQYL5GUFJ2nf2YzpA8kZmXPYr4DZBmPU\");\n\n#[program]\npub mod solciv {\n    use super::*;\n\n    pub fn initialize_game(\n        ctx: Context<InitializeGame>,\n        map: [u8; 400],\n        difficulty_level: u8,\n    ) -> Result<()> {\n        instructions::initialize_game(ctx, map, difficulty_level)\n    }\n\n    pub fn initialize_player(\n        ctx: Context<InitializePlayer>,\n        position: TileCoordinate,\n    ) -> Result<()> {\n        instructions::initialize_player(ctx, position)\n    }\n\n    pub fn initialize_npc(\n        ctx: Context<InitializeNpc>,\n        npc_position_1: TileCoordinate,\n        npc_position_2: TileCoordinate,\n    ) -> Result<()> {\n        instructions::initialize_npc(ctx, npc_position_1, npc_position_2)\n    }\n\n    pub fn move_unit(ctx: Context<MoveUnit>, unit_id: u32, x: u8, y: u8) -> Result<()> {\n        instructions::move_unit(ctx, unit_id, x, y)\n    }\n\n    pub fn upgrade_unit(ctx: Context<UpgradeUnit>, unit_id: u32) -> Result<()> {\n        instructions::upgrade_unit(ctx, unit_id)\n    }\n\n    pub fn found_city(\n        ctx: Context<FoundCity>,\n        x: u8,\n        y: u8,\n        unit_id: u32,\n        name: String,\n    ) -> Result<()> {\n        instructions::found_city(ctx, x, y, unit_id, name)\n    }\n\n    pub fn add_to_production_queue(\n        ctx: Context<AddToProductionQueue>,\n        city_id: u32,\n        item: ProductionItem,\n    ) -> Result<()> {\n        instructions::add_to_production_queue(ctx, city_id, item)\n    }\n\n    pub fn remove_from_production_queue(\n        ctx: Context<RemoveFromProductionQueue>,\n        city_id: u32,\n        index: u8,\n    ) -> Result<()> {\n        instructions::remove_from_production_queue(ctx, city_id, index)\n    }\n\n    pub fn purchase_with_gold(\n        ctx: Context<PurchaseWithGold>,\n        city_id: u32,\n        item: ProductionItem,\n    ) -> Result<()> {\n        instructions::purchase_with_gold(ctx, city_id, item)\n    }\n\n    pub fn start_research(\n        ctx: Context<StartResearch>,\n        technology_type: TechnologyType,\n    ) -> Result<()> {\n        instructions::start_research(ctx, technology_type)\n    }\n\n    pub fn upgrade_tile(ctx: Context<UpgradeTile>, x: u8, y: u8, unit_id: u32) -> Result<()> {\n        instructions::upgrade_tile(ctx, x, y, unit_id)\n    }\n\n    pub fn attack_unit(ctx: Context<AttackUnit>, attacker_id: u32, defender_id: u32) -> Result<()> {\n        instructions::attack_unit(ctx, attacker_id, defender_id)\n    }\n\n    pub fn attack_city(ctx: Context<AttackCity>, attacker_id: u32, city_id: u32) -> Result<()> {\n        instructions::attack_city(ctx, attacker_id, city_id)\n    }\n\n    pub fn create_gems(\n        ctx: Context<CreateGems>,\n        token_name: String,\n        token_symbol: String,\n        token_uri: String,\n    ) -> Result<()> {\n        instructions::create_gems(ctx, token_name, token_symbol, token_uri)\n    }\n\n    pub fn mint_gems(ctx: Context<MintGems>) -> Result<()> {\n        instructions::mint_gems(ctx)\n    }\n\n    pub fn end_turn(ctx: Context<EndTurn>) -> Result<()> {\n        instructions::end_turn(ctx)\n    }\n\n    pub fn close_game(ctx: Context<Close>) -> Result<()> {\n        instructions::close_game(ctx)\n    }\n\n    pub fn repair_wall(ctx: Context<RepairWall>, city_id: u32) -> Result<()> {\n        instructions::repair_wall(ctx, city_id)\n    }\n}\n"
    },
    "programs/solciv/src/state/city_buildings.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/city_buildings.rs",
        "originalFileName": "programs/solciv/src/state/city_buildings.rs",
        "content": "use crate::state::{TechnologyType, UnitType};\nuse anchor_lang::prelude::*;\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone)]\npub struct City {\n    pub city_id: u32,\n    pub name: String,\n    pub player: Pubkey,\n    pub game: Pubkey,\n    pub x: u8,\n    pub y: u8,\n    pub health: u32,\n    pub wall_health: u32,\n    pub attack: u32,\n    pub population: u32,\n    pub gold_yield: u32,\n    pub food_yield: u32,\n    pub production_yield: u32,\n    pub science_yield: u32,\n    pub buildings: Vec<BuildingType>,\n    pub production_queue: Vec<ProductionItem>,\n    pub accumulated_production: u32,\n    pub accumulated_food: i32,\n    pub housing: u32,\n    pub controlled_tiles: Vec<TileCoordinate>,\n    pub level: u32,\n    pub growth_points: u32,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Hash)]\npub struct TileCoordinate {\n    pub x: u8,\n    pub y: u8,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]\npub enum ProductionItem {\n    Unit(UnitType),\n    Building(BuildingType),\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]\npub enum BuildingType {\n    Barracks,\n    Wall,\n    WallMedieval,\n    WallRenaissance,\n    WallIndustrial,\n    Library,\n    School,\n    University,\n    Observatory,\n    Forge,\n    Factory,\n    EnergyPlant,\n    Market,\n    Bank,\n    StockExchange,\n    Granary,\n    Mill,\n    Bakery,\n    Supermarket,\n    ResidentialComplex,\n}\n\npub struct NewCityParams {\n    pub city_id: u32,\n    pub player: Pubkey,\n    pub game: Pubkey,\n    pub x: u8,\n    pub y: u8,\n    pub name: String,\n    pub health: u32,\n    pub controlled_tiles: Vec<TileCoordinate>,\n}\n\nimpl City {\n    pub fn new(params: NewCityParams) -> Self {\n        Self {\n            city_id: params.city_id,\n            name: params.name,\n            player: params.player,\n            game: params.game,\n            x: params.x,\n            y: params.y,\n            health: params.health,\n            controlled_tiles: params.controlled_tiles,\n            wall_health: 0,\n            attack: 0,\n            population: 1,\n            gold_yield: 2,\n            food_yield: 2,\n            production_yield: 2,\n            science_yield: 1,\n            buildings: vec![],\n            production_queue: vec![],\n            accumulated_production: 0,\n            accumulated_food: 0,\n            housing: 4,\n            level: 0,\n            growth_points: 0,\n        }\n    }\n\n    pub fn controls_tile(&self, tile_x: u8, tile_y: u8) -> bool {\n        self.controlled_tiles\n            .iter()\n            .any(|tile| tile.x == tile_x && tile.y == tile_y)\n    }\n\n    pub fn construct_building(&mut self, building_type: BuildingType) -> Result<()> {\n        match building_type {\n            BuildingType::Barracks => {\n                self.attack += 2;\n                self.housing += 1;\n            }\n            BuildingType::Wall => {\n                self.attack += 5;\n                self.wall_health = 50;\n            }\n            BuildingType::WallMedieval => {\n                self.attack += 5;\n                self.wall_health = 100;\n            }\n            BuildingType::WallRenaissance => {\n                self.attack += 10;\n                self.wall_health = 150;\n            }\n            BuildingType::WallIndustrial => {\n                self.attack += 10;\n                self.wall_health = 200;\n            }\n            BuildingType::Library => self.science_yield += 2,\n            BuildingType::School => self.science_yield += 3,\n            BuildingType::University => {\n                self.science_yield += 4;\n                self.housing += 1;\n            }\n            BuildingType::Observatory => self.science_yield += 5,\n            BuildingType::Forge => self.production_yield += 2,\n            BuildingType::Factory => self.production_yield += 3,\n            BuildingType::EnergyPlant => self.production_yield += 4,\n            BuildingType::Market => self.gold_yield += 2,\n            BuildingType::Bank => self.gold_yield += 3,\n            BuildingType::StockExchange => self.gold_yield += 4,\n            BuildingType::Granary => {\n                self.food_yield += 2;\n                self.housing += 2;\n            }\n            BuildingType::Mill => self.food_yield += 2,\n            BuildingType::Bakery => self.food_yield += 3,\n            BuildingType::Supermarket => self.food_yield += 4,\n            BuildingType::ResidentialComplex => self.housing += 5,\n        }\n        self.buildings.push(building_type);\n\n        Ok(())\n    }\n}\n\nimpl BuildingType {\n    /// returns `(base_production_cost, base_gold_cost)`\n    pub fn get_base_stats(building_type: BuildingType) -> (u32, u32) {\n        match building_type {\n            BuildingType::Barracks => (6, 100),\n            BuildingType::Wall => (10, 100),\n            BuildingType::WallMedieval => (16, 200),\n            BuildingType::WallRenaissance => (20, 250),\n            BuildingType::WallIndustrial => (28, 300),\n            BuildingType::Library => (10, 100),\n            BuildingType::School => (20, 150),\n            BuildingType::University => (30, 200),\n            BuildingType::Observatory => (40, 300),\n            BuildingType::Forge => (10, 100),\n            BuildingType::Factory => (20, 200),\n            BuildingType::EnergyPlant => (30, 300),\n            BuildingType::Market => (10, 100),\n            BuildingType::Bank => (20, 200),\n            BuildingType::StockExchange => (30, 300),\n            BuildingType::Granary => (10, 100),\n            BuildingType::Mill => (20, 200),\n            BuildingType::Bakery => (30, 300),\n            BuildingType::Supermarket => (40, 400),\n            BuildingType::ResidentialComplex => (40, 600),\n        }\n    }\n\n    pub fn get_gold_cost(building_type: BuildingType) -> u32 {\n        BuildingType::get_base_stats(building_type).1\n    }\n\n    pub fn can_construct(&self, researched_technologies: &[TechnologyType]) -> bool {\n        match self {\n            BuildingType::Barracks | BuildingType::Wall => true,\n            BuildingType::WallMedieval => {\n                researched_technologies.contains(&TechnologyType::MedievalWarfare)\n            }\n            BuildingType::WallRenaissance => {\n                researched_technologies.contains(&TechnologyType::Gunpowder)\n            }\n            BuildingType::WallIndustrial => {\n                researched_technologies.contains(&TechnologyType::TanksAndArmor)\n            }\n            BuildingType::Library => researched_technologies.contains(&TechnologyType::Writing),\n            BuildingType::School => researched_technologies.contains(&TechnologyType::Education),\n            BuildingType::University => researched_technologies.contains(&TechnologyType::Academia),\n            BuildingType::Observatory => {\n                researched_technologies.contains(&TechnologyType::Astronomy)\n            }\n            BuildingType::Bank | BuildingType::Market => {\n                researched_technologies.contains(&TechnologyType::Economics)\n            }\n            BuildingType::StockExchange => {\n                researched_technologies.contains(&TechnologyType::Capitalism)\n            }\n            BuildingType::Forge => researched_technologies.contains(&TechnologyType::IronWorking),\n            BuildingType::Granary | BuildingType::Mill => {\n                researched_technologies.contains(&TechnologyType::Agriculture)\n            }\n            BuildingType::Bakery => researched_technologies.contains(&TechnologyType::Construction),\n            BuildingType::Factory => {\n                researched_technologies.contains(&TechnologyType::Industrialization)\n            }\n            BuildingType::EnergyPlant => {\n                researched_technologies.contains(&TechnologyType::ElectricalPower)\n            }\n            BuildingType::Supermarket => {\n                researched_technologies.contains(&TechnologyType::ModernFarming)\n            }\n            BuildingType::ResidentialComplex => {\n                researched_technologies.contains(&TechnologyType::Urbanization)\n            }\n        }\n    }\n}\n"
    },
    "programs/solciv/src/state/mod.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/mod.rs",
        "originalFileName": "programs/solciv/src/state/mod.rs",
        "content": "pub mod city_buildings;\npub mod game_state;\npub mod resources_economy;\npub mod science;\npub mod units_combat;\n\npub use city_buildings::*;\npub use game_state::*;\npub use resources_economy::*;\npub use science::*;\npub use units_combat::*;\n"
    },
    "programs/solciv/src/state/resources_economy.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/resources_economy.rs",
        "originalFileName": "programs/solciv/src/state/resources_economy.rs",
        "content": "use anchor_lang::prelude::*;\n\n#[derive(AnchorSerialize, AnchorDeserialize, Copy, Clone)]\npub struct Resources {\n    pub gold: i32,\n    pub wood: u32,\n    pub stone: u32,\n    pub iron: u32,\n    pub gems: u32,\n    pub horses: u32,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone)]\npub struct Tile {\n    pub tile_type: TileType,\n    pub x: u8,\n    pub y: u8,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]\npub enum TileType {\n    LumberMill,\n    StoneQuarry,\n    Farm,\n    IronMine,\n    Pasture,\n}\n\nimpl Tile {\n    pub fn new(tile_type: TileType, x: u8, y: u8) -> Self {\n        Self { tile_type, x, y }\n    }\n}\n"
    },
    "programs/solciv/src/state/game_state.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/game_state.rs",
        "originalFileName": "programs/solciv/src/state/game_state.rs",
        "content": "use crate::consts::STORAGE_CAPACITY;\nuse crate::errors::*;\nuse crate::state::{BuildingType, City, Resources, TechnologyType, Tile, Unit};\nuse anchor_lang::prelude::*;\n\n#[account]\npub struct Game {\n    pub player: Pubkey,\n    pub npc: Pubkey,\n    pub turn: u32,\n    pub defeat: bool,\n    pub victory: bool,\n    pub map: [Terrain; 400],\n    pub difficulty_level: u8,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone)]\npub struct Terrain {\n    pub terrain: u8,\n    pub discovered: bool,\n}\n\n#[account]\npub struct Player {\n    pub game: Pubkey,\n    pub player: Pubkey,\n    pub points: u32,\n    pub cities: Vec<City>,\n    pub tiles: Vec<Tile>,\n    pub units: Vec<Unit>,\n    pub resources: Resources,\n    pub researched_technologies: Vec<TechnologyType>,\n    pub current_research: Option<TechnologyType>,\n    pub research_accumulated_points: u32,\n    pub next_city_id: u32,\n    pub next_unit_id: u32,\n}\n\n#[account]\npub struct Npc {\n    pub game: Pubkey,\n    pub player: Pubkey,\n    pub cities: Vec<City>,\n    pub units: Vec<Unit>,\n    pub next_city_id: u32,\n    pub next_unit_id: u32,\n}\n\nimpl Player {\n    fn count_barracks_buildings(cities: &[City]) -> u32 {\n        cities\n            .iter()\n            .flat_map(|city| &city.buildings)\n            .filter(|&building| matches!(building, BuildingType::Barracks))\n            .count() as u32\n    }\n\n    pub fn update_resources(\n        &mut self,\n        gold: i32,\n        wood: u32,\n        stone: u32,\n        iron: u32,\n        horses: u32,\n    ) -> Result<()> {\n        self.resources.gold = self.resources.gold.checked_add(gold).unwrap_or({\n            if gold > 0 {\n                i32::MAX\n            } else {\n                i32::MIN\n            }\n        });\n\n        let barracks_count = Self::count_barracks_buildings(&self.cities);\n        // Each barracks adds +10 to the max storage capacity\n        let max_storage_capacity = STORAGE_CAPACITY as u32 + (barracks_count * 10);\n\n        let add_resource = |current: u32, addition: u32, max_capacity: u32| -> u32 {\n            std::cmp::min(current.saturating_add(addition), max_capacity)\n        };\n\n        self.resources.wood = add_resource(self.resources.wood, wood, max_storage_capacity);\n        self.resources.stone = add_resource(self.resources.stone, stone, max_storage_capacity);\n        self.resources.iron = add_resource(self.resources.iron, iron, max_storage_capacity);\n        self.resources.horses = add_resource(self.resources.horses, horses, max_storage_capacity);\n\n        Ok(())\n    }\n\n    pub fn start_research(&mut self, technology: TechnologyType) -> Result<()> {\n        // Ensure player isn't already researching something.\n        if self.current_research.is_some() {\n            return err!(ResearchError::AlreadyResearching);\n        }\n\n        // Check if the technology can be researched.\n        if !self.can_research(&technology) {\n            return err!(ResearchError::CannotResearch);\n        }\n\n        self.current_research = Some(technology);\n        self.research_accumulated_points = 0;\n        Ok(())\n    }\n\n    pub fn add_research_points(&mut self, points: u32) -> Result<()> {\n        if self.current_research.is_some() {\n            self.research_accumulated_points += points;\n        }\n        let _ = self.complete_research();\n        Ok(())\n    }\n\n    pub fn complete_research(&mut self) -> Result<()> {\n        if let Some(technology) = &self.current_research {\n            if self.research_accumulated_points >= TechnologyType::get_cost(technology) {\n                self.researched_technologies.push(technology.clone());\n                self.current_research = None;\n                self.research_accumulated_points = 0;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn has_researched(&self, tech: &TechnologyType) -> bool {\n        self.researched_technologies.contains(tech)\n    }\n\n    pub fn can_research(&self, tech: &TechnologyType) -> bool {\n        let prev_tech = match tech {\n            TechnologyType::AnimalHusbandry\n            | TechnologyType::Writing\n            | TechnologyType::Agriculture => return true,\n            TechnologyType::Archery => TechnologyType::AnimalHusbandry,\n            TechnologyType::HorsebackRiding => TechnologyType::Archery,\n            TechnologyType::IronWorking => TechnologyType::HorsebackRiding,\n            TechnologyType::MedievalWarfare => TechnologyType::IronWorking,\n            TechnologyType::Gunpowder => TechnologyType::MedievalWarfare,\n            TechnologyType::Ballistics => TechnologyType::Gunpowder,\n            TechnologyType::TanksAndArmor => TechnologyType::Ballistics,\n            TechnologyType::Education => TechnologyType::Writing,\n            TechnologyType::Economics => TechnologyType::Education,\n            TechnologyType::Academia => TechnologyType::Economics,\n            TechnologyType::Astronomy => TechnologyType::Academia,\n            TechnologyType::Capitalism => TechnologyType::Astronomy,\n            TechnologyType::Construction => TechnologyType::Agriculture,\n            TechnologyType::Industrialization => TechnologyType::Construction,\n            TechnologyType::ElectricalPower => TechnologyType::Industrialization,\n            TechnologyType::ModernFarming => TechnologyType::ElectricalPower,\n            TechnologyType::Urbanization => TechnologyType::ModernFarming,\n        };\n        self.has_researched(&prev_tech)\n    }\n}\n"
    },
    "programs/solciv/src/utils.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/utils.rs",
        "originalFileName": "programs/solciv/src/utils.rs",
        "content": "use crate::consts::*;\n\npub fn get_new_exp(current_level: u8, current_exp: u8, exp_amount: u8) -> u8 {\n    if current_level as usize >= EXP_THRESHOLDS.len() {\n        return 0;\n    }\n\n    let max_exp = EXP_THRESHOLDS[current_level as usize];\n    let new_exp = current_exp.saturating_add(exp_amount);\n\n    if new_exp >= max_exp {\n        // Cap the experience at the max for the current level\n        max_exp\n    } else {\n        // Otherwise, just add the new experience\n        new_exp\n    }\n}\n"
    },
    "programs/solciv/src/state/science.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/science.rs",
        "originalFileName": "programs/solciv/src/state/science.rs",
        "content": "use anchor_lang::prelude::*;\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Debug)]\npub enum TechnologyType {\n    AnimalHusbandry,\n    Archery,\n    HorsebackRiding,\n    IronWorking,\n    MedievalWarfare,\n    Gunpowder,\n    Ballistics,\n    TanksAndArmor,\n    Writing,\n    Education,\n    Economics,\n    Academia,\n    Astronomy,\n    Capitalism,\n    Agriculture,\n    Construction,\n    Industrialization,\n    ElectricalPower,\n    ModernFarming,\n    Urbanization,\n}\n\nimpl TechnologyType {\n    pub fn get_cost(tech_type: &TechnologyType) -> u32 {\n        match tech_type {\n            TechnologyType::AnimalHusbandry => 7,\n            TechnologyType::Archery => 10,\n            TechnologyType::HorsebackRiding => 20,\n            TechnologyType::IronWorking => 21,\n            TechnologyType::MedievalWarfare => 30,\n            TechnologyType::Gunpowder => 42,\n            TechnologyType::Ballistics => 60,\n            TechnologyType::TanksAndArmor => 80,\n            TechnologyType::Writing => 5,\n            TechnologyType::Education => 7,\n            TechnologyType::Economics => 10,\n            TechnologyType::Academia => 14,\n            TechnologyType::Astronomy => 18,\n            TechnologyType::Capitalism => 22,\n            TechnologyType::Agriculture => 6,\n            TechnologyType::Construction => 8,\n            TechnologyType::Industrialization => 12,\n            TechnologyType::ElectricalPower => 16,\n            TechnologyType::ModernFarming => 20,\n            TechnologyType::Urbanization => 30,\n        }\n    }\n}\n"
    },
    "programs/solciv/src/state/units_combat.rs": {
        "isBinary": false,
        "fileName": "programs/solciv/src/state/units_combat.rs",
        "originalFileName": "programs/solciv/src/state/units_combat.rs",
        "content": "use crate::consts::*;\nuse crate::errors::*;\nuse crate::state::{City, TechnologyType};\nuse crate::utils::*;\nuse anchor_lang::prelude::*;\n\n#[derive(AnchorSerialize, AnchorDeserialize, Copy, Clone)]\npub struct Unit {\n    pub unit_id: u32,\n    pub player: Pubkey,\n    pub game: Pubkey,\n    pub unit_type: UnitType,\n    pub x: u8,\n    pub y: u8,\n    pub attack: u8,\n    pub health: u8,\n    pub level: u8,\n    pub experience: u8,\n    pub movement_range: u8,\n    pub remaining_actions: u8,\n    pub base_production_cost: u32,\n    pub base_gold_cost: u32,\n    pub base_resource_cost: u32,\n    pub maintenance_cost: i32,\n    pub is_ranged: bool,\n    pub is_alive: bool,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Copy, Clone, PartialEq)]\npub enum UnitType {\n    Settler,\n    Builder,\n    Warrior,\n    Archer,\n    Swordsman,\n    Crossbowman,\n    Musketman,\n    Rifleman,\n    Tank,\n    Horseman,\n}\n\nimpl Unit {\n    pub fn new(\n        unit_id: u32,\n        player: Pubkey,\n        game: Pubkey,\n        unit_type: UnitType,\n        x: u8,\n        y: u8,\n    ) -> Self {\n        let (\n            is_ranged,\n            health,\n            attack,\n            movement_range,\n            remaining_actions,\n            base_production_cost,\n            base_gold_cost,\n            base_resource_cost,\n            maintenance_cost,\n            experience,\n            level,\n        ) = Self::get_base_stats(unit_type);\n\n        Self {\n            unit_id,\n            player,\n            game,\n            unit_type,\n            x,\n            y,\n            attack,\n            health,\n            experience,\n            level,\n            movement_range,\n            remaining_actions,\n            base_production_cost,\n            base_gold_cost,\n            base_resource_cost,\n            maintenance_cost,\n            is_ranged,\n            is_alive: true,\n        }\n    }\n\n    /// Returns the base stats of a given `UnitType`.\n    ///\n    /// ### Arguments\n    ///\n    /// * `unit_type` - A `UnitType` enum variant representing the type of unit.\n    ///\n    /// ### Returns\n    ///\n    /// A tuple containing values representing the base stats of the unit in the following order:\n    /// `(is_ranged, health, attack, movement_range, remaining_actions, base_production_cost, base_gold_cost, base_resource_cost, maintenance_cost, experience, level)`.\n    pub fn get_base_stats(\n        unit_type: UnitType,\n    ) -> (bool, u8, u8, u8, u8, u32, u32, u32, i32, u8, u8) {\n        match unit_type {\n            UnitType::Settler => (false, 100, 0, 2, 1, 20, 100, 60, 0, 0, 0),\n            UnitType::Builder => (false, 100, 0, 2, 1, 20, 100, 0, 0, 0, 0),\n            UnitType::Warrior => (false, 100, 8, 2, 0, 20, 200, 0, 0, 0, 0),\n            UnitType::Archer => (true, 100, 10, 2, 0, 20, 200, 0, 1, 0, 0),\n            UnitType::Swordsman => (false, 100, 14, 2, 0, 30, 240, 10, 1, 0, 0),\n            UnitType::Horseman => (false, 100, 14, 3, 0, 30, 280, 10, 2, 0, 0),\n            UnitType::Crossbowman => (true, 100, 24, 2, 0, 40, 240, 0, 2, 0, 0),\n            UnitType::Musketman => (true, 100, 32, 2, 0, 50, 360, 0, 2, 0, 0),\n            UnitType::Rifleman => (true, 100, 40, 3, 0, 60, 420, 0, 4, 0, 0),\n            UnitType::Tank => (true, 100, 50, 4, 0, 80, 500, 0, 7, 0, 0),\n        }\n    }\n\n    pub fn get_base_cost(unit_type: UnitType) -> u32 {\n        Unit::get_base_stats(unit_type).5\n    }\n\n    pub fn get_gold_cost(unit_type: UnitType) -> u32 {\n        Unit::get_base_stats(unit_type).6\n    }\n\n    pub fn get_resource_cost(unit_type: UnitType) -> u32 {\n        Unit::get_base_stats(unit_type).7\n    }\n\n    pub fn get_base_movement_range(unit_type: UnitType) -> u8 {\n        Unit::get_base_stats(unit_type).3\n    }\n\n    pub fn get_maintenance_cost(unit_type: UnitType) -> i32 {\n        Unit::get_base_stats(unit_type).8\n    }\n\n    pub fn get_expereince(unit_type: UnitType) -> u8 {\n        Unit::get_base_stats(unit_type).9\n    }\n\n    fn can_attack(&self) -> bool {\n        // only 2 units cannot attack: Settler and Builder\n        !matches!(self.unit_type, UnitType::Settler | UnitType::Builder)\n    }\n\n    fn apply_damage(&mut self, damage: u8) {\n        if damage >= self.health {\n            self.is_alive = false;\n            self.health = 0;\n        } else {\n            self.health -= damage;\n        }\n    }\n\n    fn update_experience(&mut self, is_killer: bool) {\n        let exp_gain = if is_killer {\n            2 * EXP_PER_ATTACK\n        } else {\n            EXP_PER_ATTACK\n        };\n        self.experience = get_new_exp(self.level, self.experience, exp_gain);\n    }\n\n    pub fn attack_unit(\n        &mut self,\n        defender: &mut Unit,\n        defender_behind_the_wall: Option<bool>,\n    ) -> Result<()> {\n        // Check if the attacker is alive and of attacking type\n        if !self.is_alive || !self.can_attack() {\n            return err!(UnitError::InvalidAttack);\n        }\n\n        // Check if defender is of neutral type (Settler or Builder)\n        if matches!(defender.unit_type, UnitType::Settler | UnitType::Builder) {\n            defender.is_alive = false;\n            defender.health = 0;\n            msg!(\"Defender is dead\");\n            // set movement range to 0 so that the attacker cannot move or attack anymore\n            self.movement_range = 0;\n            return Ok(());\n        }\n        // Calculate given damage and taken damage by a formula:\n        // damage = 30 * e^((difference between combat strengths) / 25) * random_factor\n        let e: f32 = std::f32::consts::E;\n        // get the unix timestamp modulo 10 to get a number in the range [0, 9]\n        let clock = Clock::get()?;\n        let random_factor = clock.unix_timestamp % 10;\n\n        // map this to a range of [0.9, ~1.1007]\n        let multiplier: f32 = 0.9 + ((random_factor as f32) * 0.0223);\n        // @todo: do we really need the multiplier for the taken damage?\n        let taken_damage_multiplier: f32 = 1.0 / multiplier;\n        let mut given_damage_raw =\n            30.0 * e.powf((self.attack as f32 - defender.attack as f32) / 25.0) * multiplier\n                - 10.0 * (100.0 - self.health as f32) / 100.0;\n\n        if defender_behind_the_wall.is_some() {\n            // decrease given damage by 2 if defender unit behind the wall\n            given_damage_raw /= 2.0;\n        }\n\n        let taken_damage_raw = 30.0\n            * e.powf((defender.attack as f32 - self.attack as f32) / 25.0)\n            * taken_damage_multiplier\n            - 10.0 * (100.0 - defender.health as f32) / 100.0;\n\n        let given_damage = (given_damage_raw.max(0.0).min(255.0)) as u8;\n        let taken_damage = (taken_damage_raw.max(0.0).min(255.0)) as u8;\n\n        // Apply damage to defender\n        defender.apply_damage(given_damage);\n\n        // Apply damage to self (attacker)\n        self.apply_damage(taken_damage);\n\n        // Check if both units are supposed to die\n        if !self.is_alive && !defender.is_alive {\n            if given_damage >= taken_damage {\n                // Attacker dealt more damage, so it survives with 1 HP\n                // Attacker wins also in case of a tie\n                self.is_alive = true;\n                self.health = 1;\n                // Update experience considering attacker won\n                self.update_experience(true);\n            } else {\n                // Defender dealt more damage, so it survives with 1 HP\n                defender.is_alive = true;\n                defender.health = 1;\n                // Update experience considering defender won\n                defender.update_experience(true);\n            }\n        } else {\n            // If not both are dead, update experiences normally\n            self.update_experience(!defender.is_alive);\n            defender.update_experience(!self.is_alive);\n        }\n\n        // After the attack unit cannot move or attack anymore\n        self.movement_range = 0;\n\n        Ok(())\n    }\n\n    pub fn attack_city(&mut self, city: &mut City) -> Result<()> {\n        if !self.is_alive || !self.can_attack() {\n            return err!(UnitError::InvalidAttack);\n        }\n\n        // by default city don't have any defence\n        let mut city_defense = 0;\n        if city.wall_health != 0 {\n            city_defense = city.attack;\n        }\n\n        // Similar damage calculations as attack_unit\n        let e: f32 = std::f32::consts::E;\n        let clock = Clock::get()?;\n        let random_factor = clock.unix_timestamp % 10;\n        let multiplier: f32 = 0.9 + ((random_factor as f32) * 0.0223);\n        let taken_damage_multiplier: f32 = 1.0 / multiplier;\n        let given_damage =\n            (15.0 * e.powf((self.attack as f32 - city_defense as f32) / 25.0) * multiplier) as u8;\n        let taken_damage = (15.0\n            * e.powf((city_defense as f32 - self.attack as f32) / 25.0)\n            * taken_damage_multiplier) as u8;\n\n        if city.wall_health > 0 {\n            // damage for wall decreased by 2\n            let given_wall_damage = given_damage / 2;\n            // handle damage for city wall\n            if city.wall_health < given_wall_damage as u32 {\n                let city_damage = u32::from(given_wall_damage) - city.wall_health;\n                city.wall_health = 0;\n                city.health -= city_damage;\n                msg!(\"City HP after attack: {}\", city.health);\n                msg!(\"City Wall destroyed\");\n            } else {\n                city.wall_health -= u32::from(given_wall_damage);\n                msg!(\"City Wall HP after attack: {}\", city.wall_health);\n            }\n        } else {\n            msg!(\"Given damage to the city: {}\", given_damage);\n            msg!(\"Taken damage from the city: {}\", taken_damage);\n\n            // handle damage for city health\n            if u32::from(given_damage) >= city.health {\n                city.health = 0;\n                msg!(\"City has been destroyed\");\n            } else {\n                city.health -= u32::from(given_damage);\n                msg!(\"City HP after attack: {}\", city.health);\n            }\n        }\n\n        if taken_damage >= self.health {\n            self.is_alive = false;\n            self.health = 0;\n            msg!(\"Attacker is dead\");\n        } else {\n            self.health -= taken_damage;\n            msg!(\"Attacker HP after attack: {}\", self.health);\n        }\n\n        // After the attack, the unit cannot move or attack anymore.\n        self.movement_range = 0;\n\n        Ok(())\n    }\n}\n\nimpl UnitType {\n    pub fn can_recruit(&self, researched_technologies: &[TechnologyType]) -> bool {\n        match self {\n            UnitType::Settler | UnitType::Builder | UnitType::Warrior => true, // No tech required\n            UnitType::Archer => researched_technologies.contains(&TechnologyType::Archery),\n            UnitType::Horseman => {\n                researched_technologies.contains(&TechnologyType::HorsebackRiding)\n            }\n            UnitType::Swordsman => researched_technologies.contains(&TechnologyType::IronWorking),\n            UnitType::Crossbowman => {\n                researched_technologies.contains(&TechnologyType::MedievalWarfare)\n            }\n            UnitType::Musketman => researched_technologies.contains(&TechnologyType::Gunpowder),\n            UnitType::Rifleman => researched_technologies.contains(&TechnologyType::Ballistics),\n            UnitType::Tank => researched_technologies.contains(&TechnologyType::TanksAndArmor),\n        }\n    }\n}\n"
    }
}